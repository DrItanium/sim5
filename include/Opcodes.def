    X(b, 0x08)
    X(call, 0x09)
    X(ret, 0x0a)
    X(bal, 0x0b)
    // the lowest three bits are used to determine the kind of operation to
    // perform when it comes to compares, tests, faults, branches, etc
    // This maps perfectly to the condition code to be used
    X(bno, 0x10)
    X(bg, 0x11)
    X(be, 0x12)
    X(bge, 0x13)
    X(bl, 0x14)
    X(bne, 0x15)
    X(ble, 0x16)
    X(bo, 0x17)
    X(faultno, 0x18)
    X(faultg, 0x19)
    X(faulte, 0x1a)
    X(faultge, 0x1b)
    X(faultl, 0x1c)
    X(faultne, 0x1d)
    X(faultle, 0x1e)
    X(faulto, 0x1f)
    X(testno, 0x20)
    X(testg, 0x21)
    X(teste, 0x22)
    X(testge, 0x23)
    X(testl, 0x24)
    X(testne, 0x25)
    X(testle, 0x26)
    X(testo, 0x27)

    X(bbc, 0x30)
    X(cmpobg, 0x31)
    X(cmpobe, 0x32)
    X(cmpobge, 0x33)
    X(cmpobl, 0x34)
    X(cmpobne, 0x35)
    X(cmpoble, 0x36)
    X(bbs, 0x37)
    X(cmpibno, 0x38)
    X(cmpibg, 0x39)
    X(cmpibe, 0x3a)
    X(cmpibge, 0x3b)
    X(cmpibl, 0x3c)
    X(cmpibne, 0x3d)
    X(cmpible, 0x3e)
    X(cmpibo, 0x3f)
    // mem instructions are denoted to have the most significant bit of the
    // opcode set.
    //
    // The layout is somewhat baffling to me but there seems to be a method to
    // the madness the more I look at it.
    //
    // the v in the names means virtual, only found on the extended
    // architecture which I am noting here for completeness
    //
    // So the least significant bit of the major opcode denotes a virtual
    // memory operation if the lower part is 0,1,2,3 or 8,9,a,b
    // loads are always 0,1, 8, or 9  and stores are always  2, 3, a, or b
    X(ldob, 0x80)
    X(ldvob, 0x81)
    X(stob, 0x82)
    X(stvob, 0x83)
    X(bx, 0x84)
    X(balx, 0x85)
    X(callx, 0x86)
    X(ldos, 0x88)
    X(ldvos, 0x89)
    X(stos, 0x8a)
    X(stvos, 0x8b)
    X(lda, 0x8c)
    X(ld, 0x90)
    X(ldv, 0x91)
    X(st, 0x92)
    X(stv, 0x93)
    X(ldl, 0x98)
    X(ldvl, 0x99)
    X(stl, 0x9a)
    X(stvl, 0x9b)
    X(ldt, 0xa0)
    X(ldvt, 0xa1)
    X(stt, 0xa2)
    X(stvt, 0xa3)
    X(dcinva, 0xad)  // hx specific instruction
    X(ldq, 0xb0)
    X(ldvq, 0xb1)
    X(stq, 0xb2)
    X(stvq, 0xb3)
    X(ldib, 0xc0)
    X(ldvib, 0xc1)
    X(stib, 0xc2)
    X(stvib, 0xc3)
    X(ldis, 0xc8)
    X(ldvis, 0xc9)
    X(stis, 0xca)
    X(stvis, 0xcb)
    X(ldm, 0xd0)
    X(ldvm, 0xd1)
    X(stm, 0xd2)
    X(stvm, 0xd3)
    X(ldml, 0xd8)
    X(ldvml, 0xd9)
    X(stml, 0xda)
    X(stvml, 0xdb)

    X(ldmq, 0xf0)
    X(ldvmq, 0xf1)
    X(stmq, 0xf2)
    X(stvmq, 0xf3)
    // register operations
    // They have an extra 4 bits of opcode used to expand the instruction space
    // to kinda 12-bit, the range in the major opcode is 0x58->0x7F
    X(notbit, 0x580)
    X(andOperation, 0x581)
    X(andnot, 0x582)
    X(setbit, 0x583)
    X(notand, 0x584)
    X(xorOperation, 0x586)
    X(orOperation, 0x587)
    X(nor, 0x588)
    X(xnor, 0x589)
    X(notOperation, 0x58a)
    X(ornot, 0x58b)
    X(clrbit, 0x58c)
    X(notor, 0x58d)
    X(nand, 0x58e)
    X(alterbit, 0x58f)

    X(addo, 0x590)
    X(addi, 0x591)
    X(subo, 0x592)
    X(subi, 0x593)
    X(cmpob, 0x594)
    X(cmpib, 0x595)
    X(cmpos, 0x596)
    X(cmpis, 0x597)
    X(shro, 0x598)
    X(shrdi, 0x59a)
    X(shri, 0x59b)
    X(shlo, 0x59c)
    X(rotate, 0x59d)
    X(shli, 0x59e)
    // hole
    X(cmpo, 0x5a0)
    X(cmpi, 0x5a1)
    X(concmpo, 0x5a2)
    X(concmpi, 0x5a3)
    X(cmpinco, 0x5a4)
    X(cmpinci, 0x5a5)
    X(cmpdeco, 0x5a6)
    X(cmpdeci, 0x5a7)
    X(chktag, 0x5a8)
    X(cmpm, 0x5aa)
    X(scanbyte, 0x5ac)
    X(bswap, 0x5ad)
    X(chkbit, 0x5ae)

    X(addc, 0x5b0)
    X(subc, 0x5b2)
    X(intdis, 0x5b4)
    X(inten, 0x5b5)
    X(mov, 0x5cc)
    X(movm, 0x5cd)
    X(eshro, 0x5d8)
    X(movl, 0x5dc)
    X(movlm, 0x5dd)

    X(movt, 0x5ec)
    X(movq, 0x5fc)
    X(movqm, 0x5fd)

    X(synmov, 0x600)
    X(synmovl, 0x601)
    X(synmovq, 0x602)
    X(cmpstr, 0x603)
    X(movqstr, 0x604)
    X(movstr, 0x605)

    X(atmod, 0x610)
    X(atrep, 0x611)
    X(atadd, 0x612)
    X(inspacc, 0x613)
    X(ldphy, 0x614)
    X(synld, 0x615)
    X(fill, 0x617)
    // 0x62 not used
    // Cx specific instructions
    X(sdma, 0x630)
    X(udma, 0x631)

    X(spanbit, 0x640)
    X(scanbit, 0x641)
    X(daddc, 0x642)
    X(dsubc, 0x643)
    X(dmovt, 0x644)
    X(modac, 0x645)
    X(condrec, 0x646)
    X(cread, 0x648)
    X(ldtypedef, 0x649)
    X(ldglobals, 0x64a)

    X(modify, 0x650)
    X(extract, 0x651)
    X(restrictOperation, 0x652)
    X(amplify, 0x653)
    X(modtc, 0x654)
    X(modpc, 0x655)
    X(receive, 0x656)
    X(ldcsp, 0x657)
    X(intctl, 0x658)
    X(sysctl, 0x659) // Jx instruction that I am going to support the same way
                    // we do IAC instructions. The format of the sysctl
                    // "packet" is nearly identical to an IAC with the order of
                    // fields in the first 32-bit being reversed
    X(iccctl, 0x65b)
    X(dcctl, 0x65c)

    X(halt, 0x65d) // page missing from the Hx manual but in the Jx manual...
                  // oops

    X(calls, 0x660)
    X(calld, 0x661)
    X(send, 0x662)
    X(sendserv, 0x663)
    X(resumeprcs, 0x664)
    X(schedprcs, 0x665)
    X(saveprcs, 0x666)
    X(condwait, 0x668)
    X(wait, 0x669)
    X(signal, 0x66a)
    X(mark, 0x66b)
    X(fmark, 0x66c)
    X(flushreg, 0x66d)
    X(syncf, 0x66f)

    X(emul, 0x670)
    X(ediv, 0x671)
    X(cvtadr, 0x672)
    X(ldtime, 0x673)
    X(cvtir, 0x674)
    X(cvtilr, 0x675)
    X(scalerl, 0x676)
    X(scaler, 0x677)

    X(atanr, 0x680)
    X(logepr, 0x681)
    X(logr, 0x682)
    X(remr, 0x683)
    X(cmpor, 0x684)
    X(cmpr, 0x685)
    X(sqrtr, 0x688)
    X(expr, 0x689)
    X(logbnr, 0x68a)
    X(roundr, 0x68b)
    X(sinr, 0x68c)
    X(cosr, 0x68d)
    X(tanr, 0x68e)
    X(classr, 0x68f)

    X(atanrl, 0x690)
    X(logeprl, 0x691)
    X(logrl, 0x692)
    X(remrl, 0x693)
    X(cmporl, 0x694)
    X(cmprl, 0x695)
    X(sqrtrl, 0x698)
    X(exprl, 0x699)
    X(logbnrl, 0x69a)
    X(roundrl, 0x69b)
    X(sinrl, 0x69c)
    X(cosrl, 0x69d)
    X(tanrl, 0x69e)
    X(classrl, 0x69f)

    X(cvtri, 0x6c0)
    X(cvtril, 0x6c1)
    X(cvtzri, 0x6c2)
    X(cvtzril, 0x6c3)
    X(movr, 0x6c9)

    X(movrl, 0x6d9)

    X(cpysre, 0x6e2)
    X(cpyrsre, 0x6e3)
    X(movre, 0x6e9)

    X(mulo, 0x701)
    X(remo, 0x708)
    X(divo, 0x70b)

    X(muli, 0x741)
    X(remi, 0x748)
    X(modi, 0x749)
    X(divi, 0x74b)


    X(divr, 0x78b)
    X(mulr, 0x78c)
    X(subr, 0x78d)
    X(addr, 0x78f)

    X(divrl, 0x79b)
    X(mulrl, 0x79c)
    X(subrl, 0x79d)
    X(addrl, 0x79f)

    // new core instructions
    X(addono, 0x780)
    X(addog, 0x790)
    X(addoe, 0x7a0)
    X(addoge, 0x7b0)
    X(addol, 0x7c0)
    X(addone, 0x7d0)
    X(addole, 0x7e0)
    X(addoo, 0x7f0)
    X(addino, 0x781)
    X(addig, 0x791)
    X(addie, 0x7a1)
    X(addige, 0x7b1)
    X(addil, 0x7c1)
    X(addine, 0x7d1)
    X(addile, 0x7e1)
    X(addio, 0x7f1)
    X(subono, 0x782)
    X(subog, 0x792)
    X(suboe, 0x7a2)
    X(suboge, 0x7b2)
    X(subol, 0x7c2)
    X(subone, 0x7d2)
    X(subole, 0x7e2)
    X(suboo, 0x7f2)
    X(subino, 0x783)
    X(subig, 0x793)
    X(subie, 0x7a3)
    X(subige, 0x7b3)
    X(subil, 0x7c3)
    X(subine, 0x7d3)
    X(subile, 0x7e3)
    X(subio, 0x7f3)
    X(selno, 0x784)
    X(selg, 0x794)
    X(sele, 0x7a4)
    X(selge, 0x7b4)
    X(sell, 0x7c4)
    X(selne, 0x7d4)
    X(selle, 0x7e4)
    X(selo, 0x7f4)
